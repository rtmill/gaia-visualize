{
    "collab_server" : "",
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\nlibrary(shiny)\nlibrary(leaflet)\nlibrary(postGIStools)\nlibrary(RPostgreSQL)\nlibrary(maptools)\nlibrary(rgdal)\n\nshinyServer(function(input, output, session) {\n  \n \n    activeLayers <- c()\n    \n    values <- reactiveValues(\n      source = \"\",\n      importedDF = NULL,\n      customDF = NULL\n    )\n    \n    \n    repoLocation <- \"C:/Users/rmiller/Desktop/repo\"\n    \n    \n \n  \n    con <- dbConnect(PostgreSQL(), dbname = \"gis\", \n                     user = \"gis_user\",\n                     host = \"localhost\",\n                     password = \"motech\")\n    \n    \n    query <- \"select * from region.mapping\"\n    res <- dbGetQuery(con, query)\n\n    \n    polyTable <- res[1,3]\n    \n    \n\n   \n  \n\n   \n\n   \n\n\n  output$ui <- renderUI({\n    if (is.null(res))\n      return()\n    \n    \n    selectInput(\"regionType\", \"Region Type\", \n                 choices =  c(Choose='1', res$region_type))\n  })\n  \n\n  attrib <- eventReactive(input$goButton, {\n    query <- paste(\"select * from region.\",input$regionType, sep=\"\")\n    attr <- dbGetQuery(con, query)\n    attr$geoid <- as.character(attr$geoid)\n    attr\n  })\n  \n  getPoly <-  eventReactive(input$goButton, {\n    query <- paste(\"select geoid,name, geom from public.\", res$polygon_table[res$region_type == input$regionType], sep=\"\")\n    poly <- get_postgis_query(con, query,  geom_name = \"geom\")\n    \n    # Placeholder to map just ME, NH and VT\n   # poly <- poly[startsWith(poly$geoid, \"23\") | startsWith(poly$geoid, \"33\") | startsWith(poly$geoid, \"50\"),]\n    \n    poly\n  })\n  \n  \n  \n  \n  \n  \n  output$poly <- renderText({\n    names(getPoly())\n  })\n    \n  \n  obs <- observe({\n    updateSelectInput(\n      session, 'layers', \n      choices = names(attrib()[-1]),\n      selected = NULL\n    )\n  })\n \n  nChoice <- eventReactive(input$addLayer,{\n    activeLayers <<- unique(c(activeLayers, input$layers))\n    activeLayers\n  })\n  \n  output$layerChoice <- renderText({\n    nChoice()\n  })\n  \n  obs2 <- observe({\n    updateSelectInput(\n      session, 'currLayers', \n      choices = nChoice(),\n      selected = NULL\n    )\n  })  \n  \n  remChoice <- eventReactive(input$removeLayer,{\n      activeLayers <<- setdiff(activeLayers, input$currLayers)\n      activeLayers\n  })\n  \n  obs3 <- observe({\n    updateSelectInput(\n      session, 'currLayers', \n      choices = remChoice(),\n      selected = NULL\n    )\n  })    \n  \n\n  output$addedChoices <- renderDataTable({\n    \n    j <- currentDF()\n    data.frame(j)\n  })\n  \n \n \n  \n  \n  observeEvent(input$buildTable, {\n    p <- getPoly()\n    a <- attrib()\n    \n    \n    \n    for( i in 1:length(activeLayers)){\n      word <- activeLayers[i]\n      p[[word]] <- with(a, a[[word]][match(p$geoid, a$geoid)])\n    }\n    \n    output$fileStatus <- renderMenu({\n      menuItem(\"Working Table\",\n               badgeLabel = \"FOUND\", badgeColor = \"green\")\n    })\n    \n    values$customDF <- p\n    values$source <- \"custom\"\n    \n    \n  })\n  \n\n  \n  observe({\n    j <- currentDF()\n    j <- j[, -which(names(j) %in% c(\"name\",\"geoid\"))]\n    \n    \n    updateRadioButtons(\n      session, \"layerRadio\",\n      choices = c(\"None\" = \"none\", names(j))\n    )\n  })\n  \n  output$fileStatus <- renderMenu({\n    menuItem(\"Working Table\",\n             badgeLabel = \"MISSING\", badgeColor = \"red\")\n  })\n \n \n \n  \n  output$currentMap <- renderLeaflet({\n    mData <- currentDF()\n    if(is.null(mData)){\n      return()\n    }\n    \n    leaflet(mData, width=\"100%\", height=\"800px\") %>%\n      addTiles() %>% \n      addPolygons()\n  })\n  \n\n  \n  observe({\n    mData <- currentDF()\n    if(is.null(mData)){\n      return()\n    }\n    \n\n\n    if(input$layerRadio == \"none\"){\n      leafletProxy(\"currentMap\", data = mData) %>%\n        clearTiles() %>% \n        addProviderTiles(input$tiles) %>%\n        clearShapes() %>%\n        addPolygons() %>%\n        clearControls()\n    }\n    \n    else{\n      \n    layer <- mData[[input$layerRadio]]\n    \n    pal <- colorBin(\n      palette = input$colors,\n      domain = layer\n    )\n    \n   \n    \n    \n    leafletProxy(\"currentMap\", data = mData) %>%\n      clearTiles() %>% \n      addProviderTiles(input$tiles) %>%\n      clearShapes() %>%\n      addPolygons(\n        stroke=FALSE, fillOpacity=0.5, smoothFactor = 0.5,\n        color = ~pal(layer),\n        popup = paste(mData$name, \"<br>\",\n                      layer)\n      ) %>%\n      clearControls() %>%\n      addLegend(\"bottomright\", pal=pal, values= layer, title=input$layerRadio)\n\n    }\n\n  })\n  \n\n  \n  \n  \n  exportResult <- eventReactive(input$export, {\n    #writeOGR(obj= poly, dsn= \"C:/Users/rmiller/Desktop/repo\", layer=\"itWorked\", driver=\"ESRI Shapefile\")\n    \n    j <- currentDF()\n    if(is.null(j)){\n      return(\"Error: Export NOT Successful\")\n    }\n    writeSpatialShape(j, paste(repoLocation,input$layerName, sep=\"\"))\n    \n    \n    \"Export successful\"\n  })\n  \n  \n  output$exportMessage <- renderText({\n    exportResult()\n  })\n  \n  \n  \n  \n  observeEvent(input$selectImport, {\n    values$importedDF <- readOGR(repoLocation, layer=input$importLayer, stringsAsFactors = FALSE)\n    values$source <- \"imported\"\n  })\n  \n output$importMessage <- renderText({\n   importResult()\n })\n \n \n \n \n \n \n \n \n \n observeEvent(input$selectFirst, {\n   values$source <- \"imported\"\n })\n \n observeEvent(input$selectSecond, {\n   values$source <- \"custom\"\n })\n \n output$val_out <- renderText({ \n   names( currentDF() )\n   })\n \n\n \n \n currentDF <- reactive({\n   imp <- values$importedDF\n   cus <- values$customDF\n   \n   \n   switch(values$source,\n          \"imported\" = imp,\n          \"custom\" = cus\n          )\n })\n\n  \n})",
    "created" : 1472154103741.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4042102963",
    "id" : "44272721",
    "lastKnownWriteTime" : 1472153318,
    "last_content_update" : 1472153318,
    "path" : "~/G/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}